

X86_64 registers

General registers
==================

64-bit  32-bit  16-bit  8-bit
rax     eax     ax      al,ah
rbx     ebx     bx      bl,bh
rcx     ecx     cx      cl,ch
rdx     edx     dx      dl,dh
rbp     ebp     bp
rsp     esp     sp
rsi     esi     si
rdi     edi     di
rip     eip     ip
r8~r15

Segment registers
==================

cs,ds,es,fs,gs,ss


Integer Conversion
====================

1. signed => signed

widden

int8 => int64: movsbq (Signed+Byte+Quad)
int8 => int32: movsbl (Signed+Byte+Long)
int8 => int16: movsbw (Signed+Byte+Word)

int16 => int64: movswq (Signed+Word+Quad)
int16 => int32: movswl (Signed+Word+Long)

int32 => int64: cltq (Convert+Long+To+Quad)

narrow

int64 => int32: movq, movl
int64 => int16: movq, movw
int64 => int8: movq, movb

int32 => int16: movl, movw
int32 => int8: movl, movb

int16 => int8: movzwl, movb

2. unsigned => unsigned

widden

uint8 => uint64: movzbl, movq
uint8 => uint32: movzbl, movl
uint8 => uint16: movzbl, movw

uint16 => uint64: movzwl, movq
uint16 => uint32: movzwl, movl

uint32 => uint64: movl, movq


narrow

uint64 => uint32: movq, movl
uint64 => uint16: movq, movw
uint64 => uint8: movq, movb

uint32 => uint16: movl, movw
uint32 => uint8: movl, movb

uint16 => uint8: movzwl, movb

3. signed => unsigned

widden

int8 => uint16: movsbw, movw
int8 => uint32: movsbl, movl
int8 => uint64: movsbq, movq

int16 => uint32: movswl, movl
int16 => uint64: movswq, movq

int32 => uint64: movl, cltq


narrow

int64 => uint8: movq, movb
int64 => uint16: movq, movw
int64 => uint32: movq, movl

int32 => uint8: movl, movb
int32 => uint16: movl, movw

int16 => uint8: movzwl, movb


equal

int8 => uint8: movzbl, movb
int16 => uint16: movzwl, movw
int32 => uint32: movl, movl
int64 => uint64: movq, movq

4. unsigned => signed

widden

uint8 => int16: movzbl, movw
uint8 => int32: movzbl, movl
uint8 => int64: movzbl, movq

uint16 => int32: movzwl, movl
uint16 => int64: movzwl, movq

uint32 => int64: movl, movq


narrow

uint64 => int8: movq, movb
uint64 => int16: movq, movw
uint64 => int32: movq, movl

uint32 => int8: movl, movb
uint32 => int16: movl, movw

uint16 => int8: movzwl, movb


equal

uint8 => int8: movzbl, movb
uint16 => int16: movzwl, movw
uint32 => int32: movl, movl
uint64 => int64: movq, movq


MOV instruction
================

1. MOV
mov + [b,w,l,q]

2. MOVSX/MOVSD: Move with Sign-Extension
MOVSX r16, r/m8      Move byte to word with sign-extension.
MOVSX r32, r/m8      Move byte to doubleword with sign-extension.
MOVSX r64, r/m8      Move byte to quadword with sign-extension.
MOVSX r32, r/m16     Move word to doubleword with sign-extension.
MOVSX r64, r/m16     Move word to quadword with sign-extension.
MOVSXD r64, r/m32    Move doubleword to quadword with sign-extension.

movs + [b,w,l][w,l,q]
movsbw
movsbl
movsbq
movswl
movswq
movslq
cltq (CDQE in Intel Manuals, shorthand for "movslq %eax, %rax")

3. MOVZX: Move with Zero-Extend
MOVZX r16, r/m8         Move byte to word with zero-extension.
MOVZX r32, r/m8         Move byte to doubleword, zero-extension.
MOVZX r64, r/m8         Move byte to quadword, zero-extension.
MOVZX r32, r/m16        Move word to doubleword, zero-extension.
MOVZX r64, r/m16        Move word to quadword, zero-extension.

movz + [b,w][w,l,q]
movzbw
movzbl
movzbq
movzwl
movzwq


Arithmetic Instructions
========================
1. ADD: x = y + z
2. SUB: x = y - z
3. MUL: x = y * z
   INTEGER MUL
   3.1 unsigned mul
       MUL r/m8         multipy (AX <- AL * r/m8)
       MUL r/m16        multipy (DX:AX <- AX * r/m16)
       MUL r/m32        multipy (EDX:EAX <- EAX * r/m32)
       MUL r/m64        multipy (RDX:RAX <- RAX * r/m64)

   3.2 signed mul
       IMUL r/m8        AX <- AL * r/m8
       IMUL r/m16       DX:AX <- AX * r/m16
       IMUL r/m32       EDX:EAX <- EAX * r/m32
       IMUL r/m64       RDX:RAX <- RAX * r/m64

       IMUL r16, r/m16  word register <- word register * r/m16
       IMUL r32, r/m32  doubleword register <- doubleword register * r/m32
       IMUL r64, r/m64  quadword register <- quadword register * r/m64

       IMUL r16, r/m16, imm8     word register <- r/m16 * imm8
       IMUL r16, r/m16, imm16    word register <- r/m16 * imm16
       IMUL r32, r/m32, imm8     doubleword register <- r/m32 * imm8
       IMUL r32, r/m32, imm32    doubleword register <- r/m32 * imm32
       IMUL r64, r/m64, imm8     quadword register <- r/m64 * imm8
       IMUL r64, r/m64, imm32    quadword register <- r/m64 * imm32

   FLOATING MUL

4. DIV: x = y / z
   INTEGER DIV
   4.1 unsigned divide
       DIV r/m8         divide AX by r/m8, AL <- quotient, AH <- reminder
       DIV r/m16        divide DX:AX by r/m16, AX <- quotient, DX <- reminder
       DIV r/m32        divide EDX:EAX by r/m32, EAX <- quotient, EDX <- reminder
       DIV r/m64        divide RDX:RAX by r/m64, RAX <- quotient, RDX <- reminder

   4.2 signed divide
       IDIV r/m8         divide AX by r/m8, AL <- quotient, AH <- reminder
       IDIV r/m16        divide DX:AX by r/m16, AX <- quotient, DX <- reminder
       IDIV r/m32        divide EDX:EAX by r/m32, EAX <- quotient, EDX <- reminder
       IDIV r/m64        divide RDX:RAX by r/m64, RAX <- quotient, RDX <- reminder

   FLOATING DIV

5. MOD: x = y % z               (integer only)
   NOTE: the same as integer divide.
   
6. Bitwise-OR:  x = y | z       (integer only)
   OR r/m8, imm8
   OR r8, r/m8

   OR r/m16, imm8    
   OR r/m16, imm16
   OR r16, r/m16
   
   OR r/m32, imm8
   OR r/m32, imm32
   OR r32, r/m32

   OR r/m64, imm8
   OR r/m64, imm32
   OR r64, r/m64

7. Bitwise-AND: x = y & z       (integer only)
8. Bitwise-XOR: x = y ^ z       (integer only)
9. Left-SHIFT:   x = y << z     (integer only)
10. Right-SHIFT: x = y >> z     (integer only)

Shift: SAL/SAR/SHL/SHR
=======================

SAL: shift arithmetic left
SHL: shift logical left
SAR: shift arithmetic right
SHR: shift logical right

SHIFT [reg/mem], [imm8/cl]

1. SAL and SHL are the same.
2. SHR: fill with zeros
3. SAR: fill with ones

Reference
===========

1. Intel 64 and IA-32 Architecture Software Developer Manuals:
http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html

2. Using as:
https://sourceware.org/binutils/docs/as/

3. ASM64 Handout:
https://www.cs.cmu.edu/~fp/courses/15213-s07/misc/asm64-handout.pdf
