
Expression
==========

primary:
--------

(1) constant: CNSTI/CNSTU/CNSTF/CNSTP

(2)id:
       kind       op              type
     0. enum id:  CNST            integer
     1. function: ADDRGP          function
     2. array:    ADDR            array
     3. others:
                  INDIR           type
                    |
                   ADDR           ptr to type

postfix:
--------

(1) compound literal: COMPOUND
(2) (post) tree++, tree--:
  相当于 tmp = tree, tree = tree + 1, tmp

                   RIGHT
                   /   \
               RIGHT   tree
               /   \
             tree  ASGN
                   /   \
                 tree  ADD/SUB
                        /   \
                      tree   CNST (1)

    为什么不是以下这样呢？
    
                   RIGHT
                   /   \
                ASGN   tree
               /   \
             tree  ADD/SUB
                   /   \
                 tree  CNST (1)

    这里解释下：
           首先注意下，虽然画出来是树，其实是 DAG，因为 tree 都是同一个指针。
           RIGHT 树也是从左到右遍历子树。因此低层的 RIGHT 树保证了在 ASGN 树
           执行前，对 tree 树的「右值」进行计算和保存。上面的图详细的标注如下：

                   RIGHT
                   /   \
               RIGHT   tree's rvalue
               /   \
    tree's rvalue  ASGN
                   /   \
        tree's lvalue  ADD/SUB
                        /   \
            tree's rvalue   CNST (1)

    伪代码如下：
           t1 = rvalue(tree)
           t2 = lvalue(tree)
           [t2] = t1 + 1
           return t1

(3) direction: tree->id, tree.id

            MEMBER (.u.field)
              |
             tree

(4) funcall: tree()

             CALL (.u.args)
              |
             tree

(5) subscript: tree1[tree2]
  相当于 *(tree1+tree2)

                INDIR
                  |
                 ADD
                /   \
             tree1  tree2


unary:
-------

(1) sizeof:     sizeof (type-name), sizeof tree

                CNST   (integer)

(2) (prefix) ++tree, --tree:
  相当于 tree = tree + 1

             ASGN
             /   \
          tree  ADD/SUB
                /    \
              tree   CNST (1)

(3) + tree:
  相当于 tree

(4) - tree:

        NEG
         |
        tree

(5) ~ tree:

        NOT
         |
        tree

(6) ! tree:

                COND
                /   \
             tree  RIGHT
                   /   \
                ASGN   ASGN
                /  \    /  \
               t1   0  t2   1

(7) * tree:

        INDIR
          |
         tree

(8) & tree:

               kind     op              type
        1. function:    tree            ptr to function
        2. array:       tree            ptr to array
        3. others:      tree->kids[0]   kids[0]'s type


cast: (type-name) tree
-----

        CVxx
         |
        tree

binary:
-------

FORM:  tree1 op tree2

             op
            /  \
         tree1 tree2


conditional:
------------

FORM: tree0 ? tree1 : tree2

            COND
           /   \
        tree0  RIGHT
               /   \
            tree1  tree2

assignment:
-----------

FORM: tree1 = tree2, tree1 op= tree2

            ASGN
            /  \
        tree1 tree2


            ASGN
            /   \
         tree1  op
               /   \
            tree1  tree2

comma:
------

FORM: tree1, tree2, tree3, ..., treeN

             RIGHT
             /   \
           RIGHT treeN
           /  \
         RIGHT ...
         ...
        /  \
      RIGHT tree3
      /  \
   tree1 tree2

Draft
======

INTEGER_LITERAL:        CNSTI

FLOAT_LITERAL:          CNSTF

STRING_LITERAL:         CNSTP

COMPOUND_LITERAL:       ???

CAST_EXPR
CONV_EXPR:

        // Format:
        //      CV[from][to][to_size]
        //
        // i.e.:
        //      CVII4
        //
        //      Integer(? bytes) to Integer(4 bytes)
        //
        // Abbrevs:
        // I - signed integer
        // U - unsigned integer
        // F - floating
        // P - pointer
        // B - bool
        //

        // signed integer => signed integer
        CVII1
        CVII2
        CVII4
        CVII8

        // signed integer => unsigned integer
        CVIU1
        CVIU2
        CVIU4
        CVIU8

        // unsigned integer => unsigned integer
        CVUU1
        CVUU2
        CVUU4
        CVUU8

        // unsigned integer => signed integer
        CVUI1
        CVUI2
        CVUI4
        CVUI8

        // floating => floating
        CVFF4
        CVFF8
        CVFF16

        // integer => floating
        CVIF4
        CVIF8
        CVIF16

        // unsigned integer => floating
        CVUF4
        CVUF8
        CVUF16

        // floating => integer
        CVFI1
        CVFI2
        CVFI4
        CVFI8

        // floating => unsigned integer
        CVFU1
        CVFU2
        CVFU4
        CVFU8

        // integer => bool
        CVIB

        // unsigned integer => bool
        CVUB

        // floating => bool
        CVFB

        // pointer => bool
        CVPB

        // pointer???
        

BINARY_OPERATOR:

        // arith
        *: MUL: MULI, MULU, MULF
        /: DIV: DIVI, DIVU, DIVF

        ///
        +: ADD: ADDI, ADDF
        -: SUB: SUBI, SUBF

        // int
        %:  MOD: MODI, MODU
        <<: SHL: SHLI, SHLU
        >>: SHR: SHRI, SHRU
        &:  AND
        ^:  OR
        |:  XOR

        // scalar
        >:  CMP-JG/JA
        <:  CMP-JL/JB
        >=: CMP-JGE/JAE
        <=: CMP-JLE/JBE
        ==: CMP-JE/JZ
        !=: CMP-JNE/JNZ

UNARY_OPERATOR:

        // scalar
        ++ (prefix):
        -- (prefix):

                        =
                       / \
                      x   +
                         / \
                        x   1 

        ++ (postfix):
        -- (postfix):
                           ??
                         /    \
                        =      =
                       / \    / \
                      t   x  x   +
                                / \
                               x   1

        +: (skipped)
        -: NEG: NEGI, NEGU, NEGF

        !:

        // int
        ~: NOT:

        //
        &: ADDR:
        *: INDIR:

COND_EXPR:

                        ?
                      /   \
                     /     \
                   cond   RIGHT
                         /     \
                        /       \
                       =         =
                      / \       / \
                     /   \     /   \
                    t1   e1   t2   e2


CALL_EXPR:

        CALL

REF_EXPR:
        // arith

                        INDIR
                          |
                          |
                         ADDR

        // pointer

                        INDIR

        // function
        

        // struct/union

        // array
        

MEMBER_EXPR:
        e.id
        e->id

        <the same as array because of alignment of struct>
                

SUBSCRIPT_EXPR:

        base[index]
        - base: ptr
        - index: integer

                    ADD
                   /    \
                  /      \
                base     LSH
                       /    \
                    index  CNST
                            |
                           scale


INITS_EXPR:

        [0] offset  type    init(integer/floating/pointer)

        ...

        [N] offset  type    init
        


VINIT_EXPR:     (removed)

PAREN_EXPR:     (skipped)


COMMENT
========

operator:

        uint16 op;

      High                         Low
        | zzzz | zzyy | yyyy | xxxx |

        zzzz-zz: op size, [10-15], 6 bits, (1024-65535) 1,2,4,8,16
        yy-yyyy: op, [4-9], 6 bits, (16-1023)
        xxxx: op type, [0-3], 4 bits, (0-15), I,U,F,P,S

constant:

        integer: CNSTI, CNSTU
        floating: CNSTF
        string: CNSTP

identifier:

        ADDRGP: global
        ADDRPP: param
        ADDRLP: local
        

TEMPLATE
=========

        rule  "assembly code template" cost


APPENDIX
=========

x86 address model:

    disp(base, index, scale)

    disp:  integer constant
    base:  register
    index: register
    scale: 1/2/4/8

c types:

  integral types:---____ arith types ---
  floating types:---                    ----- scalar types
  pointer types: -----------------------
  array types:   ---_____ aggregate types
  struct types:  ---
  union type:
  function type:
  void type:
