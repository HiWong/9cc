
Expression
==========

primary:
        constant: CNSTI/CNSTU/CNSTF/CNSTP
        id:
             kind       op              type
           1. function: ADDRGP          function
           2. array:    ADDR            array
           3. others:
                        INDIR           type
                          |
                         ADDR           ptr to type

postfix:
        compound literal:       COMPOUND
        post ++/--:
                        RIGHT
                        /   \
                    RIGHT   node
                    /   \
                  node  ASGN
                        /   \
                      node  ADD/SUB
                             /   \
                           node   CNST (1)

         为什么不是以下这样呢？
         
                        RIGHT
                        /   \
                     ASGN   node
                    /   \
                  node  ADD/SUB
                        /   \
                      node  CNST (1)

         这里解释下：
                首先注意下，虽然画出来是树，其实是DAG，因为node都是同一个指针。
                RIGHT 树也是从左到右遍历子树。因此低层的 RIGHT 树保证了在 ASGN 树
                执行前，对 node 树的「右值」进行计算和保存。上面的图详细的标注如下：

                        RIGHT
                        /   \
                    RIGHT   node's rvalue
                    /   \
         node's rvalue  ASGN
                        /   \
             node's lvalue  ADD/SUB
                             /   \
                 node's rvalue   CNST (1)

         伪代码如下：
                 t1 = rvalue(node)
                 t2 = lvalue(node)
                 [t2] = t1 + 1
                 return t1

Draft
======

INTEGER_LITERAL:        CNSTI

FLOAT_LITERAL:          CNSTF

STRING_LITERAL:         CNSTP

COMPOUND_LITERAL:       ???

CAST_EXPR
CONV_EXPR:

        // Format:
        //      CV[from][to][to_size]
        //
        // i.e.:
        //      CVII4
        //
        //      Integer(? bytes) to Integer(4 bytes)
        //
        // Abbrevs:
        // I - signed integer
        // U - unsigned integer
        // F - floating
        // P - pointer
        // B - bool
        //

        // signed integer => signed integer
        CVII1
        CVII2
        CVII4
        CVII8

        // signed integer => unsigned integer
        CVIU1
        CVIU2
        CVIU4
        CVIU8

        // unsigned integer => unsigned integer
        CVUU1
        CVUU2
        CVUU4
        CVUU8

        // unsigned integer => signed integer
        CVUI1
        CVUI2
        CVUI4
        CVUI8

        // floating => floating
        CVFF4
        CVFF8
        CVFF16

        // integer => floating
        CVIF4
        CVIF8
        CVIF16

        // unsigned integer => floating
        CVUF4
        CVUF8
        CVUF16

        // floating => integer
        CVFI1
        CVFI2
        CVFI4
        CVFI8

        // floating => unsigned integer
        CVFU1
        CVFU2
        CVFU4
        CVFU8

        // integer => bool
        CVIB

        // unsigned integer => bool
        CVUB

        // floating => bool
        CVFB

        // pointer => bool
        CVPB

        // pointer???
        

BINARY_OPERATOR:

        // arith
        *: MUL: MULI, MULU, MULF
        /: DIV: DIVI, DIVU, DIVF

        ///
        +: ADD: ADDI, ADDF
        -: SUB: SUBI, SUBF

        // int
        %:  MOD: MODI, MODU
        <<: SHL: SHLI, SHLU
        >>: SHR: SHRI, SHRU
        &:  AND
        ^:  OR
        |:  XOR

        // scalar
        >:  CMP-JG/JA
        <:  CMP-JL/JB
        >=: CMP-JGE/JAE
        <=: CMP-JLE/JBE
        ==: CMP-JE/JZ
        !=: CMP-JNE/JNZ

UNARY_OPERATOR:

        // scalar
        ++ (prefix):
        -- (prefix):

                        =
                       / \
                      x   +
                         / \
                        x   1 

        ++ (postfix):
        -- (postfix):
                           ??
                         /    \
                        =      =
                       / \    / \
                      t   x  x   +
                                / \
                               x   1

        +: (skipped)
        -: NEG: NEGI, NEGU, NEGF

        !:

        // int
        ~: NOT:

        //
        &: ADDR:
        *: INDIR:

COND_EXPR:

                        ?
                      /   \
                     /     \
                   cond   RIGHT
                         /     \
                        /       \
                       =         =
                      / \       / \
                     /   \     /   \
                    t1   e1   t2   e2


CALL_EXPR:

        CALL

REF_EXPR:
        // arith

                        INDIR
                          |
                          |
                         ADDR

        // pointer

                        INDIR

        // function
        

        // struct/union

        // array
        

MEMBER_EXPR:
        e.id
        e->id

        <the same as array because of alignment of struct>
                

SUBSCRIPT_EXPR:

        base[index]
        - base: ptr
        - index: integer

                    ADD
                   /    \
                  /      \
                base     LSH
                       /    \
                    index  CNST
                            |
                           scale


INITS_EXPR:

        [0] offset  type    init(integer/floating/pointer)

        ...

        [N] offset  type    init
        


VINIT_EXPR:     (removed)

PAREN_EXPR:     (skipped)


COMMENT
========

operator:

        uint16 op;

      High                         Low
        | zzzz | zzyy | yyyy | xxxx |

        zzzz-zz: op size, [10-15], 6 bits, (1024-65535) 1,2,4,8,16
        yy-yyyy: op, [4-9], 6 bits, (16-1023)
        xxxx: op type, [0-3], 4 bits, (0-15), I,U,F,P,S

constant:

        integer: CNSTI, CNSTU
        floating: CNSTF
        string: CNSTP

identifier:

        ADDRGP: global
        ADDRPP: param
        ADDRLP: local
        

TEMPLATE
=========

        rule  "assembly code template" cost


APPENDIX
=========

x86 address model:

    disp(base, index, scale)

    disp:  integer constant
    base:  register
    index: register
    scale: 1/2/4/8

c types:

  integral types:---____ arith types ---
  floating types:---                    ----- scalar types
  pointer types: -----------------------
  array types:   ---_____ aggregate types
  struct types:  ---
  union type:
  function type:
  void type:
